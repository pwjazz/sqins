package org.sqins

import java.sql.Connection

/**
 * Anything the presents a list of columns
 */
trait ColumnList {
  def columns: List[Column[Any]]

  def columnsExpression = columns.mkString(", ")
}

/**
 * An unnamed list of columns
 */
case class Projection(columns: List[Column[Any]]) extends ColumnList {
  def ~[T2](nextColumnList: ColumnList) = Projection(columns ++ nextColumnList.columns)
}

/**
 * A named list of columns (table, alias, etc.)
 */
abstract class Relation(_expression: String) {
  val expression = _expression

  var alias: Option[String] = None

  /**
   * Use the alias if set, otherwise the name.
   */
  def aliasedName = alias match {
    case Some(alias: String) => alias
    case _                   => expression
  }
}

/**
 * Definition of a Table, including its name and columns.
 */
class Table[+T](_name: String) extends Relation(_name) with ColumnList {
  implicit def relation = this
  
  var columns = List[Column[Any]]()

  def addColumn(column: Column[Any]) = columns = (column :: columns).reverse

  /**
   * Alias this table.  Aliasing just creates another table of the same type but with a different name.
   */
  def AS(alias: String): this.type = {
    val constructor = this.getClass().getDeclaredConstructors()(0)
    constructor.setAccessible(true)
    val result = constructor.newInstance().asInstanceOf[this.type]
    result.alias = Some(alias)
    result.columns = columns.map { column => column.aliasedTo(result) }
    result
  }

  /**
   * For compatibility with usual SQL syntax
   */
  def * = Projection(this.columns)
}

/**
 * Represents a column in a table (or relation)
 */
case class Column[+T](name: String)(implicit table: Table[Any], typeMapping: TypeMapping[T]) extends ColumnList() {
  // Let the relation know about this Column
  table.addColumn(this)

  val columns = List(this)

  def aliasedTo(alias: Table[Any]) = Column[T](name)(alias, typeMapping)

  def ~[T2](nextColumnList: ColumnList) = Projection((this :: nextColumnList.columns).reverse)

  def :=(right: Column[Any]) = Comparison(this, "=", right)
  
  def :<>(right: Column[Any]) = Comparison(this, "<>", right)
  
  def :>(right: Column[Any]) = Comparison(this, ">", right)
  
  def :<(right: Column[Any]) = Comparison(this, "<", right)
  
  def ISNULL = Null(this)
  
  def ISNOTNULL = NotNull(this)
  
  def columnExpression = "%1$s.%2$s".format(table.aliasedName, name)

  override def toString = columnExpression
}

/**
 * Represents a conditional like A = B, A <> B, A IS NULL, etc.
 */
trait Conditional {
  def conditionalExpression: String
  
  def AND(right: Conditional) = CompoundConditional(this, "AND", right)
  
  def OR(right: Conditional) = CompoundConditional(this, "OR", right)
}

case class Comparison(left: Column[Any], comparison: String, right: Column[Any]) extends Conditional {
  val conditionalExpression = "%1$s %2$s %3$s".format(left.columnExpression, comparison, right.columnExpression)
}

case class Null(column: Column[Any]) extends Conditional {
  val conditionalExpression = "%1$s IS NULL".format(column.columnExpression)
}

case class NotNull(column: Column[Any]) extends Conditional {
  val conditionalExpression = "%1$s IS NOT NULL".format(column.columnExpression)
}

case class CompoundConditional(left: Conditional, composition: String, right: Conditional) extends Conditional {
  val conditionalExpression = "%1$s %2$s %3$s".format(left.conditionalExpression, composition, right.conditionalExpression)
}

object Implicits {
  def compositeStatementBuilderToCurrentBuilder[T <: StatementBuilder](composite: CompositeStatementBuilder[T]) = composite.currentBuilder
}

object Queries {
  def SELECT(columnList: ColumnList) = {
    val builder = new SelectStatementBuilder()
    builder.selectClause ~ columnList
  }
}

trait StatementBuilder

abstract class CompositeStatementBuilder[+T <: StatementBuilder] {
  def currentBuilder: T
}

class SelectStatementBuilder[+T <: StatementBuilder]() extends CompositeStatementBuilder[T]() {
  val selectClause = new ColumnExpressionBuilder()
  
  var currentBuilder = selectClause
}

class ColumnExpressionBuilder extends StatementBuilder {
  var columns = List[Column[Any]]()
  
  def ~(columnList: ColumnList) = {
    columns = columnList.columns ++ columns
    this
  }
}
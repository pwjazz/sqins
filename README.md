sqins - (s)tructured (q)ueries (in) (S)cala
-------------------------------------------

sqins provides type-safe SQL `INSERT`, `UPDATE`, `DELETE` and `SELECT` statements inside Scala.  sqins makes 80% of typical DML
really easy and stays out of the way for the other 20%.

**License Style** - [BSD 3 Clause](http://www.opensource.org/licenses/BSD-3-Clause)

**Status** - Alpha

**Author** - Percy Wegmann

### This is valid sqins

```scala
case class Invoice(id: Long = -1,
                   description: String,
                   image: Option[Array[Byte]] = None)

case class LineItem(id: Long = -1,
                    invoice_id: Long,
                    amount: BigDecimal,
                    ts: Timestamp = new Timestamp(System.currentTimeMillis())

// Assume that the entities Invoice and LineItem have been mapped by InvoiceTable and LineItemTable

val i = new InvoiceTable() AS "i"
val li = new LineItemTable() AS "li"

db.inTransaction { implicit conn: Connection =>
  INSERT INTO i(i.description) VALUES (?("A new invoice")) map { invoiceId =>
    for (i <- 1 to 5) {
      val newLineItem = LineItem(invoice_id = invoiceId, amount = 5 * i)
      INSERT INTO li VALUES (newLineItem) go
    }
  }
}

db.withConnection { implicit conn: Connection =>
  val query = (
    SELECT (i.*, li.*)
    FROM (i INNER_JOIN li ON i.id == li.invoice_id)
    WHERE (i.description == ?("A new invoice")))
    
  query foreach { row =>
    println(row._1.id)
    println(row._1.description)
    println(row._2.id)
    println(row._2.invoice_id)
    println(row._2.amount)
    println(row._2.ts)
  }
}
```

## Benefits

 * Looks like SQL - if you know SQL, you pretty much know sqins.
 * Strongly typed - compile time checking for SQL syntax and column types.
 * Not an ORM - sqins is just a SQL API.
 * Simple mapping - unlike an ORM, sqins just needs to know the most basic things about your tables and columns.
 * Extensible scalar types - sqins comes with support for basic types like numbers, strings and dates and makes it super-easy to define new type mappings.
 * Side-effect free - sqins doesn't cache data, maintain identity or relationships or do any other ORM funkiness.  This makes it easier to use, and makes it usable in idiomatic Scala. 
 * Smart performance - sqins employs common-sense optimizations like using PreparedStatements, streaming results from cursors, etc.
 * No SQL-injection - by using PreparedStatements and bound parameters, sqins keeps you out of SQL injection trouble.
 * Works with PostgreSQL - other databases are on the way.
 * Runs in your container - sqins doesn't care where you get your connections, so it works equally well in containerless and in-container apps.

## Installation

// TODO: publish sqins to a Maven repo

## Imports

You'll typically use these 3 imports.

```scala
import java.sql._
import org.sqins._
import org.sqins.Implicits._
```

## Mapping

### Example Database Schema

This is SQL, not Scala.

```sql
DROP TABLE IF EXISTS line_item;
DROP TABLE IF EXISTS invoice;

create table invoice (
  id SERIAL,
  description VARCHAR(255) NOT NULL,
  image BYTEA,
  primary key(id));

create table line_item (
  id SERIAL,
  invoice_id BIGINT NOT NULL,
  amount DECIMAL(22,2) NOT NULL,
  ts TIMESTAMP,
  primary key(id)); 

alter table line_item add constraint fk_line_item_invoice foreign key (invoice_id) references invoice(id);
```

Note:

* The id columns are `SERIAL`, which means that they'll be auto-generated
* The ts column on line_item has a default value, so it can be omitted from inserts

### Row Objects

sqins expects case classes to represent rows (or entities if you prefer that term).  For example:

```scala
case class Invoice(id: Long = -1,
                   description: String,
                   image: Option[Array[Byte]] = None)

case class LineItem(id: Long = -1,
                    invoiceId: Long,
                    amount: BigDecimal,
                    ts: Timestamp = new Timestamp(System.currentTimeMillis())
```                    

Note:

* These classes have no references to sqins - they're plain case classes.
* Notice that the ids, which are autogenerated in the database, are given default values.  This allows us to omit them when constructing new rows.  Note - unlike some ORMs, sqins doesn't care about the value of this, so you can use whatever you want.
* Notice that we're not mapping a relationship from `LineItem` to `Invoice`, just the foreign key itself.  sqins doesn't map associations, but as you'll see later `SELECT` queries provide powerful JOIN capabilities that make this bit of ORM complexity unnecessary. 

### Tables

You define mappings from your row objects to the database by extending the class `Table[T, K]`.

```scala
class InvoiceTable extends Table[Invoice, Long]("invoice") {
  val id = Column[Long]("id").autoGenerated
  val description = Column[String]("description")

  primaryKey(id)
  columns(id, description)
}

class LineItemTable extends Table[LineItem, Long]("line_item") {
  val id = Column[Long]("id").autoGenerated
  val invoice_id = Column[Long]("invoice_id")
  val amount = Column[BigDecimal]("amount")
  val ts = Column[Timestamp]("ts")

  primaryKey(id)
  columns(id, invoice_id, amount, ts)
  
  // Set up a query directly inside our table
  def insert(row: LineItem) = INSERT INTO (this) VALUES (row) go
}
```

Note:

* `Table` takes two type parameters, the type of row and the type of the primary key column.
* `Table` takes one class parameter, which is the name of the table in the database.
* `Column` takes one parameter, namely the Scala type to which the column is mapped.  Type mappings are automatically brought in for columns using implicits.  If you attempt to map a `Column` to a Scala type without an available type mapping, the compiler will complain.
* Columns are assigned to vals so that they can be referenced in query expressions (you'll see this later).
* Note that nullable columns like `image` are mapped with an Option type.
* Auto-generated columns such as primary key columns can be flagged using the `autoGenerated` method.
* `primaryKey(id)` configures which column is the primary key.  Right now, sqins only supports single-column primary keys but we have multi-column key support on the roadmap.
* `columns(id, description)` tells sqins what order the relevant fields appear in the constructor of the Invoice case class.  The order must match, otherwise you will have problems.
* Tables are one of several good places to collect your actual queries.  sqins doesn't care whether you collect your queries in a single place or scatter them throughout your code.
* Building queries doesn't require a database connection and they are immutable, so you can really build them anywhere at any time.
* Running queries of course depends on a database connection, which by its definition involves side effects and dependence on an unreliable and complex resource.  So, you should think carefully about what parts of your codebase actually execute queries.  Ideally, this will be isolated so that most of the system can still be operated and verified without a database. 

#### Naming and aliasing
Since tables are defined as classes, in order to use them you need to instantiate them first.

```scala
val invoice = new InvoiceTable()
val line_item = new LineItemTable()
```

You can also alias tables, which has the same effect as in SQL.  This becomes important when doing complex queries in which the same table may appear in multiple roles.

```scala
val i = invoice AS "i"
val l = line_item AS "l"
```

### Type Mappings

sqins maps fields to database columns using `TypeMapping` objects, whicih convert between the Scala type and the appropriate JDBC type.

sqins provides a `TypeMapping` for each the common basic types, and you can easily add your own.

Note - a type and its option type are considered different types, and have their own type mappings.  For example, `String` and `Option[String]` have different TypeMappings.

#### How TypeMappings are used
sqins uses `TypeMapping` implicitly.  All constructors and methods that require a `TypeMapping` (for example `Column`) accept implicit TypeMappings.  By importing `org.sqins.Implicits._` you import all of the built-in implicit TypeMappings, so you usually don't need to reference them explicitly.

#### Included TypeMappings

sqins includes TypeMappings for the following types (and their related Option types)

`Byte`  
`Short`  
`Int`  
`Long`  
`Float`  
`Double`  
`Boolean`  
`String`  
`scala.math.BigDecimal`  
`java.sql.Date`  
`java.sql.Timestamp`  
`Array[Byte]`  

#### Defining Custom TypeMappings

Since the usual style is to use `TypeMapping` implicitly, you should define your own TypeMappings as implicits as well.

A mapping for a regular type extends the `TypeMapping[T]` trait and implements the `_get` and `_set` methods.

Here's how we can define a mapping for a new type `MyType`:

```scala
case class MyType(wrapped: String)

object MyTypeMappings {
  implicit object MyTypeMapping extends TypeMapping[MyType] {
    def _get(rs: ResultSet, position: Int) =
      Extraction(MyType(rs.getString(position)), 1)
    
    def _set(ps: PreparedStatement, position: Int, value: MyType) =
      ps.setString(position, value.wrapped)
  }

  // Option types can usually be mapped by just wrapping the regular TypeMapping with an OptionTypeMapping
  implicit val OptionMyTypeMapping = new OptionTypeMapping(MyTypeMapping)
}

// To use our new type mappings, just import them
import MyTypeMappings._
```

Note:

* `Extraction` is an object that includes both the extracted value and the number of columns that were used to extract it.  Right now, sqins has only been tested with single-column values but we may eventually add support for composites.

## Setting up a Database object
Although it is not required, it is often useful to set up a Database object to make it easy to work with connections
and transactions, and also to collect all your table names and aliases in one place.

```scala
object db extends Database {
  // Our example's hoaky mechanism for getting connections
  Class.forName("org.postgresql.Driver");
  private val url = "jdbc:postgresql://localhost/sqins"
  private val props = new java.util.Properties()
  props.setProperty("user", "sqins")
  props.setProperty("password", "sqins")

  def openConnection() = DriverManager.getConnection(url, props);
  
  val invoice = new InvoiceTable()
  val i = invoice AS "i"
  val i2 = invoice AS "i2"
  val i3 = invoice AS "i3"
  val line_item = new LineItemTable()
  val li = line_item AS "li"
  val li2 = line_item AS "li2"
  val li3 = line_item AS "li3"
}
```

Note:

* sqins doesn't care where you get your connections, you just need to implement `openConnection()` to open a new
connection and give it to the Database.  For server applications, it's always a good idea to use a connection pool.
* The trait `Database` provides methods `withConnection` and `inTransaction` which we'll see in use later.
* The `Database` class does transaction management using the database connection.  If you're using JTA or something like
that, don't use `inTransaction()`.
* It's a good idea to go ahead and define several aliases for the same table in case you need them.  Since `db` is a
singleton object, it doesn't cost much and it's very convenient.

## Grammar

This section describes the full grammar of sqins.  If you want some lighter reading, skip ahead to start learning about
[INSERT queries](#INSERT). 

A SELECT query is:
```
SELECT [DISTINCT] (extractable_expression)
FROM (from_item)
[WHERE (condition)]
[ORDER_BY (expression)]
[GROUP_BY (expression)]
[LIMIT bound_value]    - database-specific
[OFFSET bound_value]   - database-specific
```

An INSERT query is:
```
INSERT INTO table [(column [, ...])]
{
  VALUES ({ bound_value [, ...] | row_object }) |
  a SELECT query
}

An UPDATE query is:
```
UPDATE (table)
SET ({ expression | row_object })
[WHERE (condition)]
```

A DELETE query is
```
DELETE FROM table
[WHERE (condition)]
```

A pure SQL query is
```
SQL("a sql string")
```

where expression is:
```
{ scalar_expression | set_expression } [, ...]
```

where scalar_expression is:
```
{ scalar_value [ ASC | DESC ] | EXPR("arbitrary SQL") }
```

where set_expression is:
```
scalar_expression := scalar_value
```

where extractable_expression is:
```
extractable_scalar [, ...]
```

where extractable_scalar is:
```
{ scalar_value | another SELECT query }
```

where scalar_value is:
```
{ column | projection | function_call | bound_value }
```

where function_call is:
```
{ predefined_function | FN("function name") } (

where projection is:
```
table.*
```

where bound_value is:
```
?(any value from your code, like a variable or a constant expression)
```

where row_object is:
```
An instance of a case class representing a row from the table being inserted/updated
```

where from_item is:
```
table [INNER_JOIN table ON condition ...]
```

where condition is:
```
{ unary_condition | binary_condition } [{ && | || } condition]
```

where unary_condition is:
```
scalar_expression { IS_NULL | IS_NOT_NULL }
```

where binary_condition is:
```
scalar_expression { == | <> | != | > | < } scalar_expression }
```

<a id="INSERT">## INSERT Queries</a>

TODO

## UPDATE Queries

TODO

## DELETE Queries

TODO

## Pure SQL Queries

TODO

## Roadmap

* Documentation
    * Create user guide
    * Include survey of other options (ScalaQuery, CircumflexORM, Squeryl)
    * Improve consistency of parentheses and explain their use
    * Clean up class and method visibility
    * Generate scaladoc
* All queries
    * Add these keywords: LIKE, ILIKE, IN, EXISTS
    * Provide nicer error messages by using @implicitNotFound
    * Support for multi-column primary keys
    * Support for no primary keys (already there, but needs testing)
    * Support for correlated subqueries in from clause
    * Indentation in query output for better readability
    * Support for type-casting functions???
    * Support for mapping to non-case classes???
* INSERT queries
    * Support for DEFAULT column values in the VALUES clause    
* SELECT queries
    * Support for left and right outer joins (includes operator similar to ScalaQuery ? to turn columns from an outer join into Option values)
    * Support for UNION, INTERSECT and EXCEPT
* UPDATE queries
    * Tighten up type checking for the SET expression (right now, it's just any expression)
* Database Support
    * MySQL
    * Oracle
    * SqlServer

### Setup in SBT

TODO:
sqins (structured queries in Scala)
===================================

sqins makes SQL INSERT, UPDATE, DELETE and SELECT statements available inside Scala.  sqins makes the 80% of typical DM
really easy and stays out of the way for the other 20%.

 * Not an ORM - sqins is just a SQL API
 * Strongly typed - compile time checking for SQL syntax and column types
 * Syntax very similar to SQL - if you know SQL, you pretty much know sqins
 * Simple object mapping - unlike an ORM, sqins just needs to know the most basic things about your tables and columns
 * Simply scalar type mapping - sqins comes with support for basic types like numbers, strings and dates and makes it super-easy to define new type mappings
 * Stateless - sqins doesn't cache data, maintain identity or relationships or do any other ORM funkiness
 * Smart performance - sqnis employs common-sense optimizations like using PreparedStatements, streaming results from cursors, etc.

### A quick example

Note - for a fuller example, take a look at core_tests.scala.

```
import java.sql._
import org.sqins.Implicits._

// Define our Scala model
case class Invoice(id: Long = 0,
                   description: String)

case class LineItem(id: Long = 0,
                    invoice_id: Long,
                    amount: BigDecimal,
                    ts: Timestamp = new Timestamp(System.currentTimeMillis))

// Define our database tables
object Invoice extends Table[Invoice, Long]("invoice") {
  val id = Column[Long]("id")
  val description = Column[String]("description")

  primaryKey(id)
  columns(id, description)
}

object LineItem extends Table[LineItem, Long]("line_item") {
  val id = Column[Long]("id").autoGenerated
  val invoice_id = Column[Long]("invoice_id")
  val amount = Column[BigDecimal]("amount")
  val ts = Column[Timestamp]("ts").autoGenerated

  primaryKey(id)
  columns(id, invoice_id, amount, ts)
}

// Set up insert methods
def insertInvoice(invoice: Invoice) = (
  INSERT INTO Invoice VALUES(invoice))
  
def insertLineItem(lineItem: LineItem) = (
  INSERT INTO LineItem VALUES(lineItem))
  
// Insert some stuff
val invoiceId = insertInvoice(Invoice(description = "An invoice"))
invoiceId match {
  case Some(invoiceId) => insertLineItem(LineItem(invoice_id = invoiceId, amount = 56.78))
  case None => // handle the fact that insert failed
} 

### Setup in SBT

TODO:

### Mapping your tables


// Rows are modeled as case classes (no dependencies on sqins API here)
case class Invoice(id: Long, description: String)

// This is a table whose rows are typed as Invoice and which is named "invoice" in the database
object Invoice extends Table[Invoice]("invoice") {
  // Columns are fields of the Table, strongly typed and given the name as used in the database
  val id = Column[Long]("id")
  val description = Column[String]("description")

  // The columns variable needs to be set a sequence of all the table's columns, in the same order as they appear in
  // the row case class constructor
  columns = Seq(id, description)
}

// Build a basic select query (doesn't require a database connection)
val query = SELECT (Invoice.*) FROM (Invoice)

// sqins queries use regular java.sql.Connections.  Get them wherever you like (datasource, etc.)
val conn:java.sql.Connection = ...

// The query is a function that takes a connection and returns an Iterable of Invoices
val result:Iterable[Invoice] = query(conn)

// Rows are streamed from the ResultSet, not read into memory as a List
result.forEach { row => ... }

// If you need to close your connection and return all rows, just use the toList method on Iterable
val resultList = result.toList

// You can also use aliases
val i = Invoice as "i"

val queryWithAlias = SELECT (i.*) FROM (i)

// You can break queries onto multiple lines by wrapping the query in parentheses
val multiLineQuery = (
  SELECT (i.*)
  FROM (i))
  
// You can select individual columns
val tupleQuery = SELECT (i.id, i.description) FROM (i)

// This gives your results as tuples
val tupleResult:Iterable[Tuple2(Long, String)] = tupleQuery(conn)

// You can even mix and match rows and tuples
val rowAndTupleQuery = SELECT (i.*, i.description) FROM (i)
var rowAndTupleResult:Iterable[Tuple2(Invoice, String)] = rowAndTupleQuery(conn)

